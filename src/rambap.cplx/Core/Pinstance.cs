using System.Diagnostics;
using System.Reflection;
using rambap.cplx.Concepts;
using rambap.cplx.PartAttributes;
using static rambap.cplx.Core.Support;

namespace rambap.cplx.Core;

/// <summary>
/// Component of Instance
/// </summary>
public class Component
{
    /// <summary>
    /// Definition if this component 
    /// </summary>
    /// Rigth now, Pinstances are created as unique C# class instance, due to Parts also begin created
    /// as unique instances of the Part class, even when reused identicaly in diferent contexts.
    /// This is wastefull, and could one day be optimised to allow components to share Pinstance class instances.
    /// Therefore a Component IS NOT a Pinstance itself, but point to one.
    public required Pinstance Instance { get; init; }

    /// <summary>
    /// Component Number : Identifier of this component in its owner
    /// </summary>
    public required string CN { get; init; } // 

    /// <summary>
    /// Comment relative to this component - eg : his purpose or usage in its owner
    /// </summary>
    public string Comment { get; init; } = "";
}

/// <summary>
/// Part Instance. The realisation of a Part, with calculated properties and relations. <br/>
/// This class is called <see cref="Pinstance"/> to avoid confusion with C# class instance.
/// </summary>
public class Pinstance
{
    /// <summary>
    /// Part Number.<br/>
    /// <b>Two Instances sharing a PN are not necessary equal</b>.
    /// </summary>
    /// This is because PN can be reused in multiple Part classes and edited in their constructor.
    public string PN { get; } // Part Number
    public string CommonName { get; } = ""; // Common name

    /// <summary>
    /// Hardware Revision
    /// </summary>
    public string Revision { get; }

    /// <summary>
    /// Cplx Model Version
    /// </summary>
    public string Version => PartType.Assembly.GetName().Version?.ToString() ?? "";

    /// <summary>
    /// C# Class type of the Part used to create this <see cref="Pinstance"/><br/>
    /// <b>Two Instances sharing a same PartType are not necessary equal</b>. 
    /// </summary>
    /// This is because Part may be edited in their constructor.
    public Type PartType { get; private init; }

    /// <summary>List of components of this instance.<br/>
    /// Owned by this instance.</summary>
    public IEnumerable<Component> Components => components;
    private List<Component> components { get; } = new();

    /// <summary> List of calculated properties of this instance <br/>
    /// These are generated by <see cref="IConcept"/>s, that evaluate the part</summary>
    public IEnumerable<IInstanceConceptProperty> Properties => properties;
    private List<IInstanceConceptProperty> properties { get; } = new();


    /// <summary> Use <see cref="System.Reflection"/> to analyse <see cref="Part"/> types and produces <see cref="Pinstance"/> </summary>
    /// <param name="template">The instantiated Part</param>
    public Pinstance(Part template) : this(template, new PartConfiguration()) { }


    private static string MakeCommment(IEnumerable<ComponentDescriptionAttribute> commentAttributes)
        => string.Join("", commentAttributes.Select(c => c.Text));

    /// <summary> Use <see cref="System.Reflection"/> to analyse <see cref="Part"/> types and produces <see cref="Pinstance"/> </summary>
    /// <param name="template">The instantiated Part</param>
    /// <param name="conf">Configuration used to decide the component to use when encountering <see cref="IAlternative"/>s </param>
    public Pinstance(Part template, PartConfiguration conf)
    {
        PartType = template.GetType();
        template.CplxImplicitInitialisation(); // is implicitly initialized

        // Select part PN
        var PNAttribute = template.GetType().GetCustomAttribute(typeof(PNAttribute)) as PNAttribute;
        // First, use PN override (set using PN property, that may specific to this Part class instance)
        if (template.PNOverride != null)
        {
            PN = template.PN; // Will use the PN Override
        }
        // Then PN Attribute
        if (PNAttribute != null)
        {
            PN = PNAttribute.PN; // PNAttribute overide PN value of the part
            template.PNOverride = PNAttribute.PN; // Update the part PN, TBD : as it is used in concept traversing the part tree
        }
        // Else, use PN
        else
        {
            PN = template.PN; // ClassName will be used as PN
        }

        // Select part CommonName
        var CommonNameAttribute = template.GetType().GetCustomAttribute(typeof(CommonNameAttribute)) as CommonNameAttribute;
        if (CommonNameAttribute != null)
        {
            CommonName = CommonNameAttribute.CommonName; // Revision attribute value is used
        }
        else
        {
            CommonName = template.CommonName; // Template Revision value is used
        }

        // Select part Revision
        var RevisionAttribute = template.GetType().GetCustomAttribute(typeof(RevisionAttribute)) as RevisionAttribute;
        if (RevisionAttribute != null)
        {
            Revision = RevisionAttribute.Revision; // Revision attribute value is used
        }
        else
        {
            Revision = template.Revision;// Template Revision value is used
        }

        // Create components from Parts properties/fields
        ScanObjectContentFor<Part>(template,
            (p, i) => components.Add(
                new Component()
                {
                    Instance = new Pinstance(p, conf),
                    CN = p.CNOverride ?? i.Name,
                    Comment = MakeCommment(i.Comments)
                }
                ));

        // Create components from IEnumarable<Parts> properties/field
        IEnumerable<Component> MakeNumberedParts(IEnumerable<Part> parts, PropertyOrFieldInfo info)
        {
            string cn_prefix = info.Name;
            int i = 1;
            return parts.Select(
                p => new Component()
                {
                    Instance = new Pinstance(p, conf),
                    CN = p.CNOverride ?? $"{cn_prefix}_{i++:00}",
                    Comment = MakeCommment(info.Comments)
                });
        }
        ScanObjectContentFor<IEnumerable<Part>>(template,
            (l, i) =>
            {
                if (l is IAlternative) return; // Avoid matching on IAlternative, witch are IEnumerable<Parts>
                components.AddRange(MakeNumberedParts(l, i));
            });

        // Select and create components from Alternatives properties/fields
        ScanObjectContentFor<IAlternative>(template,
            (a, i) =>
            {
                var selectedPart = conf.Decide(a)!;
                components.Add(
                    new Component()
                    {
                        Instance = new Pinstance(selectedPart, conf),
                        CN = selectedPart.CNOverride ?? i.Name,
                        Comment = MakeCommment(i.Comments)
                    }
                    );
            });

        // Create components for IEnumarable<Alternatives> properties/field
        IEnumerable<Component> MakeNumberedAlternatives(IEnumerable<IAlternative> alternatives, PropertyOrFieldInfo info)
        {
            string cn_prefix = info.Name;
            int i = 1;
            return alternatives.Select(
                a =>
                {
                    var selectedPart = conf.Decide(a)!;
                    return new Component()
                    {
                        Instance = new Pinstance(selectedPart, conf),
                        CN = selectedPart.CNOverride ?? $"{cn_prefix}_{i++:00}",
                        Comment = MakeCommment(info.Comments)
                    };
                });
        }
        ScanObjectContentFor<IEnumerable<IAlternative>>(template,
            (l, i) => components.AddRange(MakeNumberedAlternatives(l, i)));

        // Calculate Concepts properties
        foreach (var concept in Globals.EvaluatedConcepts)
        {
            var property = concept.MakeBase(this, template);
            if (property != null) properties.Add(property);
        }
    }
}

