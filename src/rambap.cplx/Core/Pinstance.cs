using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using rambap.cplx.Attributes;

namespace rambap.cplx.Core;

/// <summary>
/// Part Instance. The realisation of a Part Type, with calculated properties <br/>
/// This class is called <see cref="Pinstance"/> to avoid confusion with C# class instance.
/// </summary>
public class Pinstance
{
    /// <summary>
    /// Part Number.<br/>
    /// <b>Two Instances sharing a PN are not necessary equal</b>.
    /// </summary>
    /// This is because PN can be reused in multiple Part classes and edited in their constructor.
    public string PN { get; } // Part Number
    public string CommonName { get; } = ""; // Common name

    /// <summary>
    /// Hardware Revision
    /// </summary>
    public string Revision { get; }

    /// <summary>
    /// Cplx Model Version
    /// </summary>
    public string Version => PartType.Assembly.GetName().Version?.ToString() ?? "";

    /// <summary>
    /// C# Class type of the Part used to create this <see cref="Pinstance"/><br/>
    /// <b>Two Instances sharing a same PartType are not necessary equal</b>., <br/> 
    /// In the case parametric parts, with a parametered constructor, and no subclassing.
    /// </summary>
    public Type PartType { get; private init; }

    /// <summary> List of calculated properties of this instance <br/>
    /// These are generated by <see cref="IConcept"/>s, that evaluate the part</summary>
    public IEnumerable<IInstanceConceptProperty> Properties => properties;
    private List<IInstanceConceptProperty> properties { get; } = new();

    /// <summary>
    /// Component where this instance is used <br/>
    /// May be changed to a list of Component in the future, if the component / instance unicity relation is broken for optimisation
    /// </summary>
    public Component Parent { get; internal set; }

    /// <summary> Use <see cref="System.Reflection"/> to analyse <see cref="Part"/> types and produces <see cref="Pinstance"/> </summary>
    /// <param name="template">The instantiated Part</param>
    /// <param name="conf">Configuration used to decide the component to use when encountering <see cref="IAlternative"/>s </param>
    internal Pinstance(Component parent, Part template, AlternativesConfiguration conf)
    {
        Parent = parent;
        PartType = template.GetType();

        // Select part PN
        var PNAttribute = template.GetType().GetCustomAttribute(typeof(PNAttribute)) as PNAttribute;
        // First, use PN override (set using PN property, that may specific to this Part class instance)
        if (template.PNOverride != null)
        {
            PN = template.PN; // Will use the PN Override
        }
        // Then PN Attribute
        if (PNAttribute != null)
        {
            PN = PNAttribute.PN; // PNAttribute overide PN value of the part
            template.PNOverride = PNAttribute.PN; // Update the part PN, TBD : as it is used in concept traversing the part tree
        }
        // Else, use PN
        else
        {
            PN = template.PN; // ClassName will be used as PN
        }

        // Select part CommonName
        var CommonNameAttribute = template.GetType().GetCustomAttribute(typeof(CommonNameAttribute)) as CommonNameAttribute;
        if (CommonNameAttribute != null)
        {
            CommonName = CommonNameAttribute.CommonName; // Common Name attribute value is used
        }
        else if(! string.IsNullOrEmpty(template.CommonName))
        {
            CommonName = template.CommonName; // Template Common Name value is used if not empty
        }
        else
        {
            CommonName = ""; // Otherwise the Common Name is empty
        }

        // Select part Revision
        var RevisionAttribute = template.GetType().GetCustomAttribute(typeof(RevisionAttribute)) as RevisionAttribute;
        if (RevisionAttribute != null)
        {
            Revision = RevisionAttribute.Revision; // Revision attribute value is used
        }
        else
        {
            Revision = template.Revision;// Template Revision value is used
        }
    }

    internal void RunConceptEvaluation()
    {
        // Calculate Concepts properties
        foreach (var concept in Globals.EvaluatedConcepts)
        {
            var property = concept.MakeBase(Parent);
            if (property != null) properties.Add(property);
        }
    }
}

