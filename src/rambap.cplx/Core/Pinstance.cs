using System.Reflection;
using rambap.cplx.Attributes;
using static rambap.cplx.Core.Support;

namespace rambap.cplx.Core;

/// <summary>
/// Component of Instance
/// </summary>
public class Component
{
    internal Component(Pinstance parent)
    {
        Parent = parent;
    }

    /// <summary>
    /// Definition if this component 
    /// </summary>
    /// Rigth now, Pinstances are created as unique C# class instance, due to Parts also begin created
    /// as unique instances of the Part class, even when reused identicaly in diferent contexts.
    /// This is wastefull, and could one day be optimised to allow components to share Pinstance class instances.
    /// Therefore a Component IS NOT a Pinstance itself, but point to one.
    public required Pinstance Instance
    {
        get => instance!;
        set
        {
            value.Parent = this;
            instance = value;
        }
    }
    Pinstance? instance;

    internal Pinstance? Parent;

    /// <summary>
    /// Component Number : Identifier of this component in its owner
    /// </summary>
    public required string CN { get; init; } // 

    public string CID(string separator = Core.CID.Separator)
    {
        if (Parent == null)
            return CN;
        else
            return Parent!.CID() + separator + CN;
    }

    /// <summary>
    /// Comment relative to this component - eg : his purpose or usage in its owner
    /// </summary>
    public string Comment { get; init; } = "";

    /// <summary>
    /// True if this component is public or internal from this part : eg, it is visible from outside the containing Part,
    /// and therefore may be condidered to be part or the public interface of the Part.
    /// </summary>
    public required bool IsPublic { get; init; } 
}

/// <summary>
/// Part Instance. The realisation of a Part, with calculated properties and relations. <br/>
/// This class is called <see cref="Pinstance"/> to avoid confusion with C# class instance.
/// </summary>
public class Pinstance
{
    /// <summary>
    /// Part Number.<br/>
    /// <b>Two Instances sharing a PN are not necessary equal</b>.
    /// </summary>
    /// This is because PN can be reused in multiple Part classes and edited in their constructor.
    public string PN { get; } // Part Number
    public string CommonName { get; } = ""; // Common name

    /// <summary>
    /// Hardware Revision
    /// </summary>
    public string Revision { get; }

    /// <summary>
    /// Cplx Model Version
    /// </summary>
    public string Version => PartType.Assembly.GetName().Version?.ToString() ?? "";

    /// <summary>
    /// C# Class type of the Part used to create this <see cref="Pinstance"/><br/>
    /// <b>Two Instances sharing a same PartType are not necessary equal</b>. 
    /// </summary>
    /// This is because Part may be edited in their constructor.
    public Type PartType { get; private init; }

    /// <summary>List of components of this instance.<br/>
    /// Owned by this instance.</summary>
    public IEnumerable<Component> Components => components;
    private List<Component> components { get; } = new();

    /// <summary> List of calculated properties of this instance <br/>
    /// These are generated by <see cref="IConcept"/>s, that evaluate the part</summary>
    public IEnumerable<IInstanceConceptProperty> Properties => properties;
    private List<IInstanceConceptProperty> properties { get; } = new();


    /// <summary> Use <see cref="System.Reflection"/> to analyse <see cref="Part"/> types and produces <see cref="Pinstance"/> </summary>
    /// <param name="template">The instantiated Part</param>
    public Pinstance(Part template) : this(template, new PartConfiguration()) { }


    /// <summary>
    /// Component, if any, where this instance is used
    /// </summary>
    /// TODO : Using this imply Pinstance instance are unique,
    public Component? Parent { get; internal set; }
    public string CN => Parent?.CN ?? "*";
    public string CID(string separator = Core.CID.Separator)
    {
        if (Parent != null)
            return Parent.CID(separator);
        else
            return "*";
    }

    private static string MakeCommment(IEnumerable<ComponentDescriptionAttribute> commentAttributes)
        => string.Join("", commentAttributes.Select(c => c.Text));

    /// <summary> Use <see cref="System.Reflection"/> to analyse <see cref="Part"/> types and produces <see cref="Pinstance"/> </summary>
    /// <param name="template">The instantiated Part</param>
    /// <param name="conf">Configuration used to decide the component to use when encountering <see cref="IAlternative"/>s </param>
    public Pinstance(Part template, PartConfiguration conf)
    {
        PartType = template.GetType();
        if (template.ImplementingInstance != null)
            throw new InvalidOperationException("A Pinstance has already been created with this part");
        template.ImplementingInstance = this;
        template.CplxImplicitInitialization(); // run the implicit init on this part and all subparts

        // Select part PN
        var PNAttribute = template.GetType().GetCustomAttribute(typeof(PNAttribute)) as PNAttribute;
        // First, use PN override (set using PN property, that may specific to this Part class instance)
        if (template.PNOverride != null)
        {
            PN = template.PN; // Will use the PN Override
        }
        // Then PN Attribute
        if (PNAttribute != null)
        {
            PN = PNAttribute.PN; // PNAttribute overide PN value of the part
            template.PNOverride = PNAttribute.PN; // Update the part PN, TBD : as it is used in concept traversing the part tree
        }
        // Else, use PN
        else
        {
            PN = template.PN; // ClassName will be used as PN
        }

        // Select part CommonName
        var CommonNameAttribute = template.GetType().GetCustomAttribute(typeof(CommonNameAttribute)) as CommonNameAttribute;
        if (CommonNameAttribute != null)
        {
            CommonName = CommonNameAttribute.CommonName; // Common Name attribute value is used
        }
        else if(! string.IsNullOrEmpty(template.CommonName))
        {
            CommonName = template.CommonName; // Template Common Name value is used if not empty
        }
        else
        {
            CommonName = PN; // Otherwise the Common Name is the PN
        }

        // Select part Revision
        var RevisionAttribute = template.GetType().GetCustomAttribute(typeof(RevisionAttribute)) as RevisionAttribute;
        if (RevisionAttribute != null)
        {
            Revision = RevisionAttribute.Revision; // Revision attribute value is used
        }
        else
        {
            Revision = template.Revision;// Template Revision value is used
        }

        // Create components from Parts properties/fields
        ScanObjectContentFor<Part>(template,
            (p, i) => components.Add(
                new Component(this)
                {
                    Instance = new Pinstance(p, conf),
                    CN = p.CNOverride ??
                        (i.IsFromAndEnumerable ? $"{i.Name}_{i.IndexInEnumerable:00}" : i.Name),
                    Comment = MakeCommment(i.Comments),
                    IsPublic = i.IsPublicOrAssembly,
                }),
            ignoredDerivedTypes : [typeof(IAlternative)] // Avoid matching on alternative, who are IEnumerable<Part>
            );

        // Select and create components from Alternatives properties/fields
        ScanObjectContentFor<IAlternative>(template,
            (a, i) =>
            {
                var selectedPart = conf.Decide(a)!;
                components.Add(
                new Component(this)
                {
                    Instance = new Pinstance(selectedPart, conf),
                    CN = selectedPart.CNOverride ??
                        (i.IsFromAndEnumerable ? $"{i.Name}_{i.IndexInEnumerable:00}" : i.Name),
                    Comment = MakeCommment(i.Comments),
                    IsPublic=i.IsPublicOrAssembly,
                });
            });

        // Calculate Concepts properties
        foreach (var concept in Globals.EvaluatedConcepts)
        {
            var property = concept.MakeBase(this, template);
            if (property != null) properties.Add(property);
        }
    }
}

